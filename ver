#!/bin/bash
#############################################################################
## C O N F I G     V A R S                                                 ##
##-------------------------------------------------------------------------##
##Basedir: You need to change this to your needs
DIR="/home/julio/NAS/Download/transmission/completed/"
##You must chage the path to your own db
SQLITE="sqlite /home/julio/bin/sver/verdb"
##Change this to your favourite player with the options you like
PLAYER="vlc -f --no-loop --play-and-exit"
#############################################################################

#Don't touch code from here unless you know what you are doing
#   | | |
#   v v v

#Current version
VERSION="0.1.7"

function help {
	echo "ver $VERSION - Copyleft (GPL v3) Julio Serrano 2016"
	echo "Series and films watching mate"
	echo
	echo "Modo de empleo: ver [opción] <título>"
	echo
	echo " Ejemplos:"
	echo
	echo "   Para reproducir archivos que contengan 'xyz'"
	echo "   \$> ver xyz"
	echo
	echo "   Para ver un episodio de Better call Saul"
	echo "   \$> ver better call saul"
	echo
	echo " Puede introducir un máximo de nueve palabras."
	echo " El script no tiene en cuenta mayúsculas y minúsculas."
	echo
	echo "Opciones"
	echo " -v"
	echo "      Para listar también medios ya vistos."
	echo
	echo " -nv"
	echo "      Para listar todos los medios que no hayan sido reproducidos."
	echo
	echo " ^<título>"
	echo "      Ir directamente al episodio siguiente de la serie."
	echo
	echo " -r, --reset"
	echo "      Reiniciar serie"
	echo
	echo " -rn, --reset~n"
	echo "      En ambos casos se debe sustituir 'n' por un número."
	echo "      Volver 'n' episodios atrás en la serie."	
	echo
	echo " -b, --back"
	echo "      Volver un episodio atrás."	
}

function trim {
    echo $*
}

function makeFilename {
	local filename="$1"
	filename=`echo "$filename" | sed s/u000A//g`
	filename=$(basename "$filename")
	echo "$filename"
}

function getFile {
	local filename="$1"
	filename=$(makeFilename "$filename")

	id=`$SQLITE "select id from file where filename = \"$filename\""`
	echo $id
}

function insertFile {
	local filename="$1"
	filename=$(makeFilename "$filename")

	#filename=`echo "$filename" | sed s/u000A//g`
	#filename=$(basename "$filename")
	$SQLITE "insert into file  (filename) values (\"$filename\")"

	echo $(getFile "$filename")
}

function getVisto {
	id=$1

	visto=`$SQLITE "select veces from visto where id=$id"`
	echo $visto
}

function insertVisto {
	id=$1

	$SQLITE "insert into visto values ($id, 1)"
}

function addVisto {
	id=$1

	$SQLITE "update visto set veces=veces+1 where id=$id"
	echo "$(getVisto "$id")"
}

function isVisto {
	local filename="$1"
	#filename=$(makeFilename "$filename")

	local id=$(getFile "$filename")
	if [[ ${#id} == 0 ]]; then
		echo 0
	else
		echo $(getVisto "$id")
	fi	
}

function goForth {
	local filename="$1"

	local ID=$(getFile "$filename")
	#echo $ID

	if [[ ${#ID} == 0 ]]; then

		#It is not, let's insert it
		ID=$(insertFile "$filename")
		#echo $ID
		$(insertVisto "$ID")
		#echo "Has visto este archivo $VECES veces"

	else

		#The file is already in the db, so we update visto
		VECES=$(addVisto "$ID")

	fi		
}

function reset {
	local filename="$1"

	DATA=`$SQLITE "select id from file where filename like \"%$filename%\""`
	for id in $DATA; do
		#echo "Borrando Id: $id"
		$SQLITE "delete from visto where id=$id"
		$SQLITE "delete from file where id=$id"
	done
	echo "Reset completado a $filename"
}

function resetBackOne {
	local filename="$1"

	local id=`$SQLITE "select max(id) from file where filename like \"%$filename%\""`
	local idSize=${#id}

	if [[ $idSize == 0 ]]; then
		echo false
	else
		$SQLITE "delete from visto where id=$id"
		$SQLITE "delete from file where id=$id"
		echo true
	fi
}

function resetBy {
	local filename="$1"
	local by=$2

	for ((i=0; i<$by; i++)); do
		local res=$(resetBackOne "$filename" "$by")
		if ! $res; then
			echo "Reset interrumpido antes de finalizar"
			break
		fi
	done
	echo "Reset finalizado a $filename"
}

TEMP=`getopt -o bfhnrv: --long "back,forth,forth-by:,forth-all,help,reset,mreset:,reset-by:" -- "$@"`

# Debug
#echo "$TEMP"
if [ $? != 0 ] ; then help ; exit 1 ; fi

# Note the quotes around `$TEMP': they are essential!
eval set -- "$TEMP"

VER_NO_VISTOS=false
VER_VISTOS=false
forth_number=0
forth_all=false
reset=false
reset_by=false
back=0
reset_data=()

while true; do
  case "$1" in
  	-h | --help ) help; exit ;;
	-b | --back ) let back++; shift ;;
	-f | --forth ) let forth_number++; shift ;;
	--forth-by ) forth_number=$2; shift 2 ;;
	--forth-all ) forth_all=true; shift ;;
	-n ) VER_NO_VISTOS=true; shift ;;
    -v ) VER_VISTOS=true; shift ;;
	-r | --reset ) reset=true; shift ;;
	--mreset ) reset_data+=("$2"); shift 2 ;;
	--reset-by ) reset_by=true; bydata=$2; shift 2 ;;
    * ) break ;;
  esac
done

PARM=""
for arg in $@; do
	if [[ $1 != "--" ]]; then
		PARM="$PARM$1 "
	fi
	shift
done

PARM=$(trim $PARM)

echo "ver $VERSION - Copyleft (GPL v3) Julio Serrano 2016"
echo "Helper to watch series video files and films"
echo

if $reset; then
	reset "$PARM"
fi

if $reset_by; then
	resetBy "$PARM" $bydata
fi

if [[ ${#reset_data} > 0 ]]; then
	echo "Número de peticiones de mreset: ${#reset_data}"
	for part in ${reset_data[@]}; do
		echo "$part"
		reset "$part"
		if [[ $PARM == "" ]]; then
			PARM="$part"
		fi
	done
fi

while [[ $back > 0 ]]; do
	res=$(resetBackOne "$PARM")
	
	let back--
done
unset res


# VER_NO_VISTOS=false
# VER_VISTOS=false
# forth_number=0
# forth_all=false
# #Reset BY veriable
# rstby="--reset~"
# rstby2="-r"
# frthby="--forth~"
# frthby2="--f"

# if [[ $1 == "--reset" ]] || [[ $1 == "-r" ]]; then
# 	PARM="$(trim "$2 $3 $4 $5 $6 $7 $8 $9")"
# 	reset "$PARM"
# 	#exit 0
# elif [[ $1 == $rstby* ]]; then
# 	PARM="$(trim "$2 $3 $4 $5 $6 $7 $8 $9")"
# 	bydata=$1
# 	resetBy "$PARM" ${bydata:8}
# 	#exit 0
# elif [[ $1 == $rstby2* ]]; then
# 	PARM="$(trim "$2 $3 $4 $5 $6 $7 $8 $9")"
# 	bydata=$1
# 	resetBy "$PARM" ${bydata:2}
# 	#exit 0
# elif [[ $1 == "--back" ]] || [[ $1 == "-b" ]]; then
# 	PARM="$(trim "$2 $3 $4 $5 $6 $7 $8 $9")"
# 	res=$(resetBackOne "$PARM")
# 	unset res
# 	echo "Paso atrás completado"
# 	#exit
# elif [[ $1 == "--forth" ]] || [[ $1 == "-f" ]]; then
# 	forth_number=1
# 	#Get args into PARH variable
# 	PARM="$(trim "$2 $3 $4 $5 $6 $7 $8 $9")"	
# elif [[ $1 == "--forth~all" ]]; then
# 	forth_all=true
# 	PARM="$(trim "$2 $3 $4 $5 $6 $7 $8 $9")"	
# elif [[ $1 == $frthby* ]]; then
# 	forth_number=${1:8}
# 	#Get args into PARH variable
# 	PARM="$(trim "$2 $3 $4 $5 $6 $7 $8 $9")"	
# elif [[ $1 == $frthby2* ]]; then
# 	forth_number=${1:2}	
# 	#Get args into PARH variable
# 	PARM="$(trim "$2 $3 $4 $5 $6 $7 $8 $9")"
# elif [[ $1 == "-v" ]]; then
# 	VER_VISTOS=true
# 	#Get args into PARH variable
# 	PARM="$(trim "$2 $3 $4 $5 $6 $7 $8 $9")"
# elif [[ $1 == "-nv" ]]; then
# 	VER_NO_VISTOS=true
# 	#Get args into PARH variable
# 	PARM="*"
# else
# 	#Get args into PARH variable
# 	PARM="$(trim "$1 $2 $3 $4 $5 $6 $7 $8 $9")"
# fi

#Play next episode
#This option is no compatible with -v or -nv
DIRECTO=false
if [[ $PARM == ^* ]]; then
	PARM=${PARM:1}
	DIRECTO=true
fi

#Go to base dir where files are located
cd $DIR

echo "Buscando: >$PARM<"
echo
if $VER_NO_VISTOS; then
	#Find all files
	find * -name '*.avi' -o -name '*.mp4' -o -name '*.mkv' -type f | sort > /tmp/films.txt
else
	#Find files that match with your args
	find * -name '*.avi' -o -name '*.mp4' -o -name '*.mkv' -type f | grep -i "$PARM" | sort > /tmp/films.txt
fi

FILE=$(</tmp/films.txt)
SIZE=${#FILE}

#If there were no results
if [[ $SIZE == 0 ]]; then
	echo "No hay coincidencias"
else
	#Read films.txt into array IN
	readarray IN < /tmp/films.txt
	#We no longer need films.txt
	rm /tmp/films.txt

	#If there was just a result
	#there's no need for menu
	if [[ ${#IN[*]} == 1 ]]; then

		FILM="$FILE"
		echo "He encontrado este archivo:"
		echo "$FILM"

	else

		QUEDA=false
		primero=true
		#As there were several results, we show a menu with all of them
		for index in ${!IN[*]}
		do
			ITERA=${IN[$index]}
			if $VER_VISTOS; then
				sign=" "
				if [[ $(isVisto "$ITERA") == 0 ]]; then	
					if $primero; then
						sign=">"
						primero=false
					else
						sign=" "
		    		fi
				fi
				printf " $sign$index:\t$ITERA"
		    	QUEDA=true
		    else
		    	if [[ $(isVisto "$ITERA") == 0 ]]; then
			    	if [[ $forth_number > 0 ]] || $forth_all; then
			    		goForth "$ITERA"
			    		let forth_number--
			    	else
		    			printf "  $index:\t$ITERA"	
				    	QUEDA=true
				    	if $DIRECTO; then
				    		echo "Reproducir directamente el siguiente"
				    		FILM="$ITERA"
				    		break
				    	fi
		    		fi
		    	fi
		    fi
			#if [ $(isVisto "${IN[$index]}") ] || $VER_VISTOS; then
		    #	printf " $index: ${IN[$index]}"
		    #	QUEDA=true
		    #fi
		done

		if ! $QUEDA; then
			echo "Usted ya ha visto todos los archivos coincidentes"
			echo "Si a pesar de todo quiere volver a verlos, use \"ver -v $PARM\""
			exit
		fi
		

		if ! $DIRECTO; then

			echo
			echo "Introduzca el número del archivo que quiere ver:"
			read REPLY
			echo

			#We see if the user entered a number such as we need
			LIMITE=$(( ${#IN[*]} - 1 ))
			#LIMITE2=$(( LIMITE - 1 ))
			while [ "$REPLY" -lt 0 ] || [ "$REPLY" -gt  $LIMITE ]; do

				#We give advice to the user and exit
				echo "Tiene que introducir un número de entre los señalados:"
				read REPLY

			done

			CHOSEN=${IN[REPLY]}
			if [ ${#CHOSEN} == 0 ]; then
				echo "Debe elegir entre los que se le ofrecen"
				exit 1
			else
				echo "Ha elegido:"
				echo "  $CHOSEN"
				FILM="$CHOSEN"
			fi

		fi
	fi


	#Remove \n chars from the string to avoid vlc errors
	FILM=`echo $FILM | sed s/u000A//g`
	#echo "$FILM" | hexdump -c

	#Get just the filename without the path
	FILENAME=$(basename "$FILM")

	#Check if the file has been watched before
	#Look if the file is already in the db
	ID=$(getFile "$FILENAME")
	#echo $ID

	if [[ ${#ID} == 0 ]]; then

		echo "  Es la primera vez que va a ver este archivo"

	else
		
		VECES=$(addVisto "$ID")
		
		echo "  Ha visto este archivo $VECES veces"
	fi

	#About to start playing. Let's warn the user and pause
	echo "  La reproducción va a comenzar..."
	echo
	if ! $DIRECTO; then
		read -rsp $'  Pulsa ENTER para continuar o CTRL^C para abortar...\n'
	fi

	#Call vlc to play the selected file
	${PLAYER} "${FILM}" &
	echo
	echo "Reproducción en progreso..."

	#Make annotations in the db that this file has been watched
	#Look if the file is already in the db
	ID=$(getFile "$FILENAME")
	#echo $ID

	if [[ ${#ID} == 0 ]]; then

		#It is not, let's insert it
		ID=$(insertFile "$FILENAME")
		#echo $ID
		$(insertVisto "$ID")
		#echo "Has visto este archivo $VECES veces"

	else

		#The file is already in the db, so we update visto
		VECES=$(addVisto "$ID")

	fi	
fi